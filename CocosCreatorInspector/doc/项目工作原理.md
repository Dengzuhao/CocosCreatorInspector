# chrome cocos inspector 工作原理

> Author: huzi(moustache)<br>
> Date: 18-7-27 15:45

本项目使用技术如下：

 1. chrome插件开发
 2. vue-cli
 3. webpack
 3. gulp

## 项目目录

总目录：

~~~bash
$ tree . -L 1 
.
├── README.md
├── bin
├── doc
├── gulpfile.js
├── package-lock.json
├── package.json
├── src
├── webpack.config.js
├── 如何运行项目.md
└── 数据结构设计思路.md
~~~

 - dist：源代码编译后的文件夹。
 - node_modules：vue-cli生成的库。
 - src：vue-cli源码，包含chrome插件开发内容，通过webpack编译vue到dist中。
 - gulpfile.js：通过gulp将编译后的代码打包成crx压缩包。
 - webpack.config.js：webpack详细过程。

src目录：

~~~bash
$ tree src -L 2
.
├── assets
│   └── images
├── dev
│   ├── backgroundScripts.js
│   ├── contentScripts.js
│   ├── dev.html
│   ├── dev.js
│   ├── devInspector
│   └── injectedScripts
├── index
│   ├── App.vue
│   ├── index.html
│   └── main.js
├── manifest.json
└── popup
    ├── App.vue
    ├── main.js
    └── popup.html
~~~

 - manifest.json：chrome插件配置文件。关键文件。
 - dev/devInspector: devtools的配置文件夹。
 - dev/injectedScripts: 要注入原页面的文件夹，包含各种需要需要注入到原页面的js脚本。
 - dev/backgroundScripts.js: chrome背景线程脚本。

## 项目编译原理：


## 项目运行原理：

和一般的chrome插件类似，项目中的脚本可分成两个部分：

 1. 注入原页面的injectedScript，用来获取节点信息，之后传递给devtools。位于dev/injectedScripts文件夹内。
 2. 在devtools上加载的vue脚本，用来渲染页面，并动态绑定传来的节点信息。位于dev/devInspector文件夹内。

项目运行分为三个阶段：

 1. 将vue模板实例化，渲染devtools的界面。
 2. 建立连接（服务端）等待原界面（客户端）发送的数据，两者的通讯过程如下图。
 3. 向原页面注入injectedScript。

![](photo/通讯图.png)

PS：经测试，通过chrome.runtime.sendMessage可以一步到位，不太明白这样搞两个跳板的作用。= =

项目成功运行后，数据的双向绑定的过程如下：

 - 正向：devtools修改节点属性值，通过eval函数，执行注入脚本中的接口函数，更新原页面上的对应节点属性。
 - 反向：原页面的属性变化后，通过一系列异步通讯，将变化后的属性传递给devtools。

## 项目运行过程细节：

### 1. 将vue模板实例化，渲染devtools的界面

整个vue模板的入口位于devInspector/main.js，在main.js内部，进行了两件事。
 
 - 进行其他模板初始化：

~~~js
// main.js
// 自定义util函数加载
import util from './util.js'
util();
// 其他模板加载
Vue.component('Node', MyNode);
Vue.component('SlideNode', SlideNode);
// ...... other template load
~~~

 - 将App.vue挂载到devInspector/devInspector.html上：

~~~js
// main.js
Vue.use(ElementUI);
new Vue({
  el: '#app',
  render: h => h(App)
});
~~~

因此，实际的入口其实是App.vue。在App.vue中，渲染左边的树形节点和右边的属性框。

 - 左边的树形节点：

~~~html
<!-- App.vue -->
<el-tree :data="treeData"
            :props="defaultProps"
            :expand-on-click-node="true"
            @node-click="handleNodeClick">
</el-tree>
~~~

 - 右边的属性框：属性框中包括节点属性和挂载在节点上的脚本属性。

~~~html
<!-- App.vue -->
<NodeBaseProperty :itemData="treeItemData"></NodeBaseProperty>
<ComponentsProperty :components="treeItemData.components"></ComponentsProperty>
~~~

属性框中模板层层嵌套，在此不展开描述。

### 2. 建立连接（服务端）等待原界面（客户端）发送的数据

先连接background，然后在backgrond添加监听器。

监听器收到消息后，更新数据，再由vue的双向绑定机制重新渲染页面上节点。

~~~js
// App.vue
created() {
    let backgroundPageConnection = chrome.extension.connect({
        name: btoa("for" + String(chrome.devtools.inspectedWindow.tabId))
    });

    backgroundPageConnection.onMessage.addListener(function (message) {
        // handle message
    });
}
~~~

### 3. 向原页面注入injectedScript

"刷新"按钮点击后，触发函数。

通过import，得到三个需要注入的脚本，最后通过chrome.devtools.inspectedWindow.eval()写入原页面。

~~~js
// App.vue
onBtnClickUpdatePage() {
    let code = this._getInjectScriptString(injectPluginInit);
    chrome.devtools.inspectedWindow.eval(code);
    code = this._getInjectScriptString(injectConnectInit);
    chrome.devtools.inspectedWindow.eval(code);
    code = this._getInjectScriptString(injectScript);
    chrome.devtools.inspectedWindow.eval(code, function () {
        console.log("刷新成功!");
    });
}
~~~

一共注入三个脚本，其中：
 - connectInit.js：声明通讯结构。
 - pluginInit.js：声明eval调用的接口函数。
 - injectScript.js：才是实际运行的代码。

~~~js
// injectScript.js
// 存在cc空间，游戏存在
if (isCocosCreatorGame) {
    // 添加节点刷新帧
    cc.director.on(cc.Director.EVENT_AFTER_DRAW, function () {
        // 每一定时间提醒devtools更新节点
    }(), cc.director);
    // 发送节点树信息
    window.sendNodeTreeInfo();
} else {
    console.log("未发现cocos creator game");
}
~~~

发送的节点树包含所有节点的uuid。

发送节点树的同时，会将节点树上的节点储存在window.inspectorGameMemoryStorage(map: key - uuid, value - node/component)中。接口函数则调用window.inspectorGameMemoryStorage更新数据。

### 4. 正向绑定过程

节点属性值修改，触发changeValue函数。（在）



