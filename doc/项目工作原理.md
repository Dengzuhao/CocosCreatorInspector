# chrome cocos inspector 工作原理

> Author: huzi(moustache)<br>
> Date: 18-7-27 15:45

本项目使用技术如下：

 1. chrome插件开发
 2. vue-cli
 3. webpack
 3. gulp

## 项目目录

### 总目录：

~~~bash
$ tree . -L 1 
.
├── README.md
├── bin
├── dist
├── doc
├── gulpfile.js
├── node_modules
├── package-lock.json
├── package.json
├── src
├── theme
└── webpack.config.js
~~~

 - dist：源代码编译后的文件夹。
 - node_modules：vue-cli依赖的库。
 - src：vue-cli源码，包含chrome插件开发内容，通过webpack编译vue到dist中。
 - gulpfile.js：通过gulp将编译后的代码打包成crx压缩包。
 - webpack.config.js：webpack详细过程。
 - theme：用于修改element-ui中CSS属性的文件夹。

### src目录：

~~~bash
$ tree src -L 2
src
├── assets
│   └── images
├── config
│   ├── injectedScripts.json
│   └── nodebase.json
├── dev
│   ├── backgroundScripts.js
│   ├── contentScripts.js
│   ├── dev.html
│   ├── dev.js
│   ├── devInspector
│   └── injectedScripts
├── index
│   ├── App.vue
│   ├── index.html
│   └── main.js
├── manifest.json
└── popup
    ├── App.vue
    ├── main.js
    └── popup.html
~~~

 - manifest.json：chrome插件配置文件。关键文件。
 - dev：目录。开发的主要目录。
 - index：目录。插件配置页。
 - popup：目录。popup页。
 - config：目录。用户可以自己修改config中的json文件，json说明请见doc/config规范.md。

### dev目录（主要开发）

~~~shell
$ tree src/dev -L 2
src/dev
├── backgroundScripts.js
├── contentScripts.js
├── dev.html
├── dev.js
├── devInspector
│   ├── App.vue
│   ├── basenode
│   ├── compositenode
│   ├── devInspector.html
│   ├── main.js
│   ├── plugin.js
│   └── util.js
└── injectedScripts
    ├── connect.js
    ├── debugGraphics.js
    ├── enum.js
    ├── main.js
    ├── plugin.js
    ├── storage.js
    ├── timer.js
    └── util.js
~~~

 - backgroundScripts.js：chrome背景页脚本
 - contentScripts.js：chrome在页面加载结束后注入原页面的脚本
 - dev.html/dev.js：用于生成Cocos-panel
 - devInspector：devtools部分
    - App.vue：用于渲染Cocos-panel上的界面
    - basenode：目录，包含着各种基本组件模版
    - compositenode：目录，包含着各种组合后的组件模板，一般是由basenode组合而来
    - util.js：包含各种util函数
 - injectedScripts：注入原页面的部分
    - connect.js：声明通讯结构
    - debugGraphics.js：DEBUG模式中，cc.Graphics渲染边框的代码
    - main.js：检测页面是否包含cocos游戏，并初始化节点树，设置定时器
    - plugin.js：包含eval调用的接口函数
    - util.js：主要包含debugGraphics中使用的结构和函数


## 项目编译原理：

### 1. npm install

通过package.json文件安装指定依赖。

### 2. npm run build

build在package.json文件中，对应的指令"cross-env NODE_ENV=production webpack --progress --hide-modules"

其中，cross-env NODE_ENV=production作用是可以跨平台设置NODE_ENV变量，webpack --progress --hide-modules是为了打包时显示进度条，并且忽略依赖的第三方模块。

执行完毕后，chrome插件所需要的文件和mainfest.json都会被编译到dist文件夹里。

PS：webpack打包执行的指令在webpack.config.js中，可以看到以下这种情况：

~~~js
    entry: {
        devInspector: path.resolve(__dirname, './src/dev/devInspector/main.js'),
    },
    //devInspector.html
    new HtmlWebpackPlugin({
      template: __dirname + "/src/dev/devInspector/devInspector.html",
      filename: 'devInspector.html',
      inject: 'body',
      chunks: ['devInspector']
    }),
~~~

此处意思是直接将main.js注入到html中，而main.js实际上渲染的是App.vue，因此App.vue才是文件入口。

### 3. gulp packageCrx

执行gulpfile.js中的packageCrx命令。该命令将执行：

~~~shell
$ chrome.exe --pack-extension=./dist --pack-extension-key=./bin/dist.pem
~~~

由于chrome插件根据密钥判断是否为同一个插件，因此需要dist.pem文件。

打包后就可以在bin文件夹里获得cc-inspector.crx。

## 项目运行原理：

和一般的chrome插件类似，项目中的脚本可分成两个部分：

 1. 注入原页面的injectedScript，用来获取节点信息，之后传递给devtools。位于dev/injectedScripts文件夹内。
 2. 在devtools上加载的vue脚本，用来渲染页面，并动态绑定传来的节点信息。位于dev/devInspector文件夹内。

项目运行分为三个阶段：

 1. 将vue模板实例化，渲染devtools的界面。
 2. 建立连接（服务端）等待原界面（客户端）发送的数据，两者的通讯过程如下图。
 3. 向原页面注入injectedScript。

![](photo/通讯图.png)

项目成功运行后，数据的双向绑定的过程如下：

 - 正向：devtools修改节点属性值，通过eval函数，执行注入脚本中的接口函数，更新原页面上的对应节点属性。
 - 反向：原页面的属性变化后，通过一系列异步通讯，将变化后的属性传递给devtools。

## 项目运行过程代码细节：

### 1. 将vue模板实例化，渲染devtools的界面

整个vue模板的入口位于devInspector/main.js，在main.js内部，进行了两件事。
 
 - 进行其他模板初始化：

~~~js
// main.js
// 自定义util函数加载
import util from './util.js'
util();
// 其他模板加载
Vue.component('Node', MyNode);
Vue.component('SlideNode', SlideNode);
// ...... other template load
~~~

 - 将App.vue挂载到devInspector/devInspector.html上：

~~~js
// main.js
Vue.use(ElementUI);
new Vue({
  el: '#app',
  render: h => h(App)
});
~~~

因此，实际的入口其实是App.vue。在App.vue中，渲染左边的树形节点和右边的属性框。

 - 左边的树形节点：

~~~html
<NodeTreeProperty :treeData="treeData"
                nodeKey="uuid"
                ref="tree">
</NodeTreeProperty>
~~~

 - 右边的属性框：属性框中包括节点属性和挂载在节点上的脚本属性。

~~~html
<NodeBaseProperty :itemData="treeItemData"></NodeBaseProperty>
<ComponentsProperty :components="treeItemData.components"></ComponentsProperty>
~~~

属性框中模板层层嵌套，在此不展开描述，详情请见后面的模板详解。

### 2. 建立连接（服务端）等待原界面（客户端）发送的数据

由于background是持续时间最长的脚本程序，因此连接建立在background基础上。

先连接background，然后在backgrond添加监听器。

监听器收到消息后，更新数据，再由vue的双向绑定机制重新渲染页面上节点。

~~~js
// App.vue
created() {
    let backgroundPageConnection = chrome.extension.connect({
        name: btoa("for" + String(chrome.devtools.inspectedWindow.tabId))
    });

    backgroundPageConnection.onMessage.addListener(function (message) {
        // handle message
    });
}
~~~

### 3. 向原页面注入injectedScript

"刷新"按钮点击后，触发函数。

通过import，得到六个需要注入的文件，最后通过chrome.devtools.inspectedWindow.eval()写入原页面。

~~~js
import injectPlugin from "../injectedScripts/plugin.js";
import injectConnect from "../injectedScripts/connect.js";
import injectMain from "../injectedScripts/main.js";
import injectDebugDOM from "../injectedScripts/debugGraphics.js";
import injectUtil from "../injectedScripts/util.js"
import injectConfig from "../../config/injectedScripts.json";

// App.vue
onBtnClickUpdatePage() {
      // 注入脚本
      let code = this._getInjectScriptString(injectUtil);
      chrome.devtools.inspectedWindow.eval(code);
      code = this._getInjectScriptString(injectConnect);
      chrome.devtools.inspectedWindow.eval(code);
      code = this._getInjectScriptString(injectPlugin);
      chrome.devtools.inspectedWindow.eval(code);
      // 注入config
      code = this._getConfigObjString();
      chrome.devtools.inspectedWindow.eval(code);
      code = this._getInjectScriptString(injectDebugDOM);
      chrome.devtools.inspectedWindow.eval(code);
      code = this._getInjectScriptString(injectMain);
      chrome.devtools.inspectedWindow.eval(code, function() {
        console.log("刷新成功!");
      });
}
~~~

一共注入五个脚本和一个配置文件，其中：
 - connect.js：声明通讯结构。
 - plugin.js：声明eval调用的接口函数。
 - main.js：实际运行的代码。
 - debugGraphics.js：构造并刷新QuadNode树，使用Graphics绘制边框。
 - util.js：包含各种util函数和变量，例如storage变量。
 - injectedScripts.json：配置文件，里面定义了参数的属性。

~~~js
// main.js
  // 检测是否包含cc变量
  // 如果存在cc空间，游戏存在
  if (cc) {
    if (!ccIns.isNotFirst) {
      ccIns.isNotFirst = true;
      // 添加节点刷新帧
      cc.director.on(cc.Director.EVENT_AFTER_DRAW, function () {
          // ...
      }, cc.director);

      // 添加节点树刷新帧
      cc.director.on(cc.Director.EVENT_AFTER_DRAW, function () {
          // ...
      }, cc.director);

      // 检测cc.Graphics是否存在
      if (cc.Graphics) {
        // 添加Graphics刷新帧
        cc.director.on(cc.Director.EVENT_AFTER_DRAW, function () {
            // ...
        }, cc.director);
      } else {
        ccIns.sendMsgToDevTools(ccIns.Connect.msgType.notSupport, "不支持Debug模式!");
        console.log("can't use Debug model");
      }
    }

    // 发送节点树数据
    ccIns.sendNodeTreeInfo();
  } else {
    ccIns.sendMsgToDevTools(ccIns.Connect.msgType.notSupport, "不支持调试游戏!");
    console.log("not find cocos creator game");
  }
~~~

发送的节点树包含所有节点的uuid。

发送节点树的同时，会将节点树上的节点储存在ccIns.gameMemoryStorage中。接口函数则通过ccIns.gameMemoryStorage中的节点更新数据。

### 4. 正向数据绑定过程

修改节点：

 1. 通过_evalCode()，向原页面注入脚本，运行plugin.js中的接口函数，修改节点属性。
 2. 节点属性修改完毕后，通过_freshNode()，运行接口函数getNodeInfo()，发送更新后的信息给devtools，显示修改后的属性。

修改树：

 1. 通过_evalCode()，向原页面注入脚本，运行plugin.js中的接口函数，修改树层级。
 2. 树的层级改变后，通过树的自动更新，显示修改后的树。

### 5. 反向数据绑定过程

节点刷新：

 1. 通过cc.director.on绑定触发器，触发器定时发送信号。
 2. devtools收到信号后，重新获取数据，刷新界面。

树刷新：

 1. 触发器定时发送节点树信息。
 2. devtools收到节点树信息后，与当前节点树比较，如果不同，更新现有节点树。

## vue模板详解：

devtools中的vue模板分为三个部分：

~~~shell
├── App.vue
├── basenode
│   ├── ArrayNode.vue
│   ├── BoolNode.vue
│   ├── ColorNode.vue
│   ├── EnumNode.vue
│   ├── MultiNumberNode.vue
│   ├── NumberNode.vue
│   ├── StringNode.vue
│   ├── VectorNode.vue
│   ├── left
│   │   ├── Node.vue
│   │   └── SlideNode.vue
│   └── right
│       ├── CheckBox.vue
│       ├── ColorPicker.vue
│       ├── InputBox.vue
│       └── SelectBox.vue
└── compositenode
    ├── ComponentProperty.vue
    ├── ComponentsProperty.vue
    ├── NodeBaseProperty.vue
    └── NodeTreeProperty.vue

~~~

 - App.vue：devtools顶层模板，使用compositenode中的模板。
 - compositenode：目录。中间层模板。
    - ComponentProperty.vue：脚本模板，只显示一个脚本的属性信息。依赖basenode。
    - ComponentsProperty.vue：节点组件模板，显示一个节点中所有脚本的信息。依赖ComponentProperty.vue。
    - NodeBaseProperty.vue：节点属性模板，显示一个节点中属性的信息，依赖basenode。
    - NodeTreeProperty.vue：节点树模板，显示节点树中节点的信息。
 - basenode：目录。底层模板。
    - BoolNode.vue：选择框，表示bool属性。
    - NumberNode.vue：单行单个属性显示，表示number和string属性。依赖Node.vue/SlideNode.vue。
    - VectorNode.vue：单行多个属性显示，表示数组属性。依赖Node.vue/SlideNode.vue。
    - Node.vue/SlideNode.vue：可滑动节点和不可滑动节点模板。

## DEBUG_MODE实现详解：

此部分借助cocos中的两个api：

  1. cc.Graphics组件，主要通过stroke()绘制线段。
  2. node.getNodeToWorldTransform()，获得节点的世界变换坐标系。

首先，构造一个新的节点，该节点和Canvas同样大小，再增加一个Graphics组件到该节点下，用于边框的绘制。

~~~js
// debugGraphics.js
// 生成Graphics挂载节点和Graphics脚本
let node = new cc.Node();
node.name = "Debug-Graphics";
node.addComponent("cc.Graphics");
ccCanvas.parent.addChild(node);
ccIns.graphicsNode = node;
let config = ccIns.Config.DEBUG_MODE;
let gracom = node.getComponent("cc.Graphics");
gracom.lineWidth = config.lineWidth;

// 设置节点属性
node.active = false; // 一开始隐藏
node.anchorX = 0;
node.anchorY = 0;
node.width = ccCanvas.width;
node.height = ccCanvas.height;
~~~

然后，通过scene节点树，构造一个树形结构，即util.js中的QuadNode结构。该树会一直刷新。

> QuadNode包含QuadRangle，QuadRangle中的四个变量代表着一个节点的四个顶点。通过node的width，height和getNodeToWorldTransform()转换而来。绘制的时候，只需要绘制节点代表的四条线即可。

~~~js
// debugGraphics.js
// 生成树根节点
ccIns.QuadNode.root = new ccIns.QuadNode(ccCanvas);

// ......

// 更新Graphics树
// PS:只更新不绘制
ccIns.updateGraphicsTree = function (quadroot, ccroot) {
    // ......
};

// main.js
// 添加Graphics刷新帧
cc.director.on(cc.Director.EVENT_AFTER_DRAW, function () {
    // ...
    // 更新Graphics树
    ccIns.updateGraphicsTree(ccIns.QuadNode.root, cc.Canvas.instance.node);
    // ...
}, cc.director);
~~~

接下来，设置节点的hover和click触发器。使鼠标移动和点击的时候，设置对应的节点。绘制则每帧进行绘制。

~~~js
// debugGraphics.js
// 绑定hover
node.on(cc.Node.EventType.MOUSE_MOVE, function (e) {
    // 得到当前鼠标位置的四边形
    let node = e.target;
    if (node.active) {
        let pos = e.getLocation();
        let quadnodes = getQuadsContainPos(pos);
        let quadnode = getNearestQuad(quadnodes, pos);
        // 设置hover节点
        if (ccIns.QuadNode.hover != quadnode) {
            ccIns.QuadNode.hover = quadnode;
        }
    }
}, node);

// 绑定click
node.on(cc.Node.EventType.MOUSE_DOWN, function (e) {
    // 设置clicked节点
    if (ccIns.QuadNode.clicked != ccIns.QuadNode.hover) {
        ccIns.QuadNode.clicked = ccIns.QuadNode.hover;
    }
    // 同步到节点树
    if (ccIns.QuadNode.clicked) {
        ccIns.sendMsgToDevTools(ccIns.Connect.msgType.clickedNodeInfo, ccIns.QuadNode.clicked.uuid);
    }
}, node);

// 绘制hover和clicked节点，每帧刷新
ccIns.drawNode = (function () {
    // ......
    return function () {
        // ......
    };
})();

// main.js
// 添加Graphics刷新帧
cc.director.on(cc.Director.EVENT_AFTER_DRAW, function () {
    // ...
    // 更新Graphics树
    ccIns.updateGraphicsTree(ccIns.QuadNode.root, cc.Canvas.instance.node);
    // 绘制节点
    ccIns.drawNode();
    // ...
}, cc.director);
~~~

最后，在plugin.js中新增api，即可实现双向绑定效果。

~~~js
// 显示QuadRangle边框，并去除之前的QuadRangle边框
ccIns.clickQuadNode = function (uuid) {
    // ......
    // 获得quadnode节点，并且设置成clicked
    let quadnode = ccIns.getObjectFromStorage(uuid, "quadNode");
    if (quadnode && ccIns.QuadNode.clicked != quadnode) {
        ccIns.QuadNode.clicked = quadnode;
    }
};
~~~